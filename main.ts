/**
 * Extension providing event blocks for claps.
 */
//% color="#AA278D" weight=100
namespace claps {
    const NO_CLAP_TIMEOUT = 1000;               // max gap between claps in wake sequence
    const POST_WAKE_CAPTURE_TIMEOUT = 2000;     // max gap/how long to wait between wake and any following counted claps
    const POLLING_TIME = 100;                   // how often to check for clap sequences

    enum Status {
        AWAITING_WAKE,
        CAPTURING_POST_WAKE,
        CAPTURING_COMPLETE
    }

    /**
     * Used to detect claps and start event handlers. Singleton class - use getClapDetector() to get instance.
     * Works by registering DetectedSound.Loud onSoud events as claps.
     */
    class ClapDetector {
        private static singletonClapDetector : ClapDetector;
        static getClapDetector() {
            if (!ClapDetector.singletonClapDetector) {
                ClapDetector.singletonClapDetector = new ClapDetector();
            }
            return ClapDetector.singletonClapDetector;
        }

        private clapTimes: number[];        // list of times (millis) that claps are recorded
        private lastClapTime: number;

        private wokenAt: number;            // time (millis) that wake word recognised

        private captureClapCount: number;   // counting claps after woken

        private onLoudHandler: ()=>void;    // generated by updateOnLoudHandler()
        private onClapInstance: ()=>void;   // allows event handler for every instance of a clap
        private onWakeDetected: ()=>void;   // triggered on wake - i.e. if a capture handler is matched
        private onCaptureOver: ()=>void;    // triggered once waiting for capture handler has expired

        // lists of clap handlers that have been registered with the ClapDetector
        private handlers: ClapHandler[];
        private captureHandlers: ClapCaptureHandler[];  // capture handlers also record num claps after woken

        private status: Status;

        private constructor() {
            this.clapTimes = [];
            this.handlers = [];
            this.captureHandlers = [];
            this.captureClapCount = 0;
            this.updateOnLoudHandler();
            this.status = Status.AWAITING_WAKE;

            input.onSound(DetectedSound.Loud, this.onLoudHandler);  // clap instance detect event

            // every POLLING_TIME ms check if any handlers match and execute
            loops.everyInterval(POLLING_TIME, () => {
                if (!this.lastClapTime) {   // no claps yet registered
                    return
                }

                if (this.status === Status.CAPTURING_COMPLETE) {    // reset
                    this.status = Status.AWAITING_WAKE;
                    this.clapTimes = [];
                    this.lastClapTime = undefined;
                    this.captureClapCount = 0;
                    this.wokenAt = undefined;
                    return;
                }

                // if not woken yet and timout has passed then handle
                if (this.status === Status.AWAITING_WAKE && control.millis() - this.lastClapTime >= NO_CLAP_TIMEOUT) {
                    this.status = Status.CAPTURING_POST_WAKE;   // important to ensure following claps start being counted right away
                    let toRun = [];
                    for (let handler of this.handlers) {
                        if (handler.isValid(this.clapTimes)) {  // if handler matches then execute
                            toRun.push(handler);
                        }
                    }

                    let anyValidCHandlers = false;              // check if we have any capture handlers to start counting for
                    for (let cHandler of this.captureHandlers) {
                        if (cHandler.isValid(this.clapTimes)) {
                            anyValidCHandlers = true;
                            if (this.onWakeDetected) {
                                this.onWakeDetected();
                            }
                        }
                    }
                    this.status = anyValidCHandlers ? Status.CAPTURING_POST_WAKE : Status.CAPTURING_COMPLETE;
                    if (anyValidCHandlers) {
                        this.wokenAt = control.millis();
                    }

                    for (let handler of toRun) {
                        handler.fn();
                    }
                }

                // if have capture handlers and are counting - check if timed out, if so execute handler fn.
                if (this.status === Status.CAPTURING_POST_WAKE) {
                    const t = control.millis()
                    const sinceWake = t - this.wokenAt
                    const sinceClap = t - this.lastClapTime
                    if (sinceWake >= POST_WAKE_CAPTURE_TIMEOUT && sinceClap >= POST_WAKE_CAPTURE_TIMEOUT) {
                        for (let cHandler of this.captureHandlers) {
                            if (cHandler.woken) {
                                if (this.onCaptureOver) {
                                    this.onCaptureOver();
                                }
                                cHandler.fn(this.captureClapCount);
                                cHandler.reset();
                            }
                        }
                        this.status = Status.CAPTURING_COMPLETE;
                    }
                }
            })
        }

        /**
         * Generates the handler to run when onLoud event detected.
         *  - Will call onClapInstance handler if set.
         *  - If capturing after woken then adds to count.
         *  - Normally will add a new clap to the list.
         */
        updateOnLoudHandler() {
            this.onLoudHandler = () => {
                if (this.onClapInstance) {
                    this.onClapInstance();
                }
                if (this.status === Status.CAPTURING_POST_WAKE) {
                    this.captureClapCount ++;
                    this.lastClapTime = control.millis();
                } else {
                    let time = control.millis();
                    this.clapTimes.push(time);
                    this.lastClapTime = time;
                }
            }
        }

        /**
         * Register a new clap handler
         * @param x number of claps to trigger
         */
        setXClapHandler(x: number, handler: ()=>void) {
            let isValid = (clapTimes: number[]) => {
                return clapTimes.length === x;
            }
            this.handlers.push(new ClapHandler(isValid, handler));
        }

        /**
         * Register a new clap handler that also captures a count of following claps until timeout specified by
         * POST_WAKE_CAPTURE_TIMEOUT. THen calls handler with the count.
         * @param x number of claps to trigger
         */
        setXClapCaptureHandler(x: number, handler: (count: number)=>void) {
            let isValid = (clapTimes: number[]) => {
                return clapTimes.length === x;
            }
            this.captureHandlers.push(new ClapCaptureHandler(isValid, handler));
        }

        /**
         * A handler that will run every time a clap is detected without any checking if it is alone.
         * @param handler
         */
        setOnClapInstanceHandler(handler: ()=>void) {
            this.onClapInstance = handler;
            this.updateOnLoudHandler();
        }

        /**
         * A handler that will run every time a capture handler is found to be valid/matched.
         * Means that the wake sequence for that capture handler has been met so it is woken.
         */
        setOnWakeDetected(handler: ()=>void) {
            this.onWakeDetected = handler;
        }

        /**
         * A handler that will run every time a capture handler times out.
         */
        setOnCaptureOver(handler: ()=>void) {
            this.onCaptureOver = handler;
        }
    }

    /**
     * Handler that can be added to the ClapDetector.
     *  - isValid: function taking clapTimes - true if the handler matches this, false otherwise.
     *  - fn: the function to run once detected.
     */
    class ClapHandler {
        isValid: (clapTimes : number[]) => boolean;
        fn: any;

        constructor(isValid: (clapTimes: number[])=>boolean, fn: ()=>void) {
            this.isValid = isValid;
            this.fn = fn;
        }
    }

    /**
     * Extends ClapHandler. Includes woken attribute based on whether it has been woken or not.
     */
    class ClapCaptureHandler extends ClapHandler {
        woken: boolean;

        constructor(isValid: (clapTimes: number[])=>boolean, fn: (count: number)=>void) {
            super(isValid, ()=>{});
            this.isValid = (clapTimes: number[]) => {
                this.woken = isValid(clapTimes);
                return this.woken;
            };
            this.fn = fn;
            this.woken = false;
        }

        reset() {
            this.woken = false;
        }
    }


    /* --- BLOCKS --- */

    //% block="on one clap"
    export function onOnelap(handler: ()=>void) {
        let clapDetector = ClapDetector.getClapDetector();
        clapDetector.setXClapHandler(1, handler);
    }

    //% block="on double clap"
    export function onDoubleClap(handler: ()=>void) {
        let clapDetector = ClapDetector.getClapDetector();
        clapDetector.setXClapHandler(2, handler);
    }

    //% block="on triple clap"
    export function onTripleClap(handler: ()=>void) {
        let clapDetector = ClapDetector.getClapDetector();
        clapDetector.setXClapHandler(3, handler);
    }

    //% block="on $x claps"
    //% x.min=1 x.max=20
    export function onXClap(x: number, handler: ()=>void) {
        let clapDetector = ClapDetector.getClapDetector();
        clapDetector.setXClapHandler(x, handler);
    }

    //% block="on $x claps followed by $count single claps"
    //% x.min=1 x.max=20
    //% draggableParameters="reporter"
    export function onXClapsCapture(x: number, handler: (count: number)=>void) {
        let clapDetector = ClapDetector.getClapDetector();
        clapDetector.setXClapCaptureHandler(x, handler);
    }

    //% block="on double clap followed by $count single claps"
    //% draggableParameters="reporter"
    export function onDoubleClapsCapture(handler: (count: number)=>void) {
        let clapDetector = ClapDetector.getClapDetector();
        clapDetector.setXClapCaptureHandler(2, handler);
    }

    //% block="on triple clap followed by $count single claps"
    //% draggableParameters="reporter"
    export function onTripleClapsCapture(handler: (count: number)=>void) {
        let clapDetector = ClapDetector.getClapDetector();
        clapDetector.setXClapCaptureHandler(3, handler);
    }

    //% block="on clap instance"
    //% advanced="true"
    export function onClapInstance(handler: ()=>void) {
        let clapDetector = ClapDetector.getClapDetector();
        clapDetector.setOnClapInstanceHandler(handler);
    }

    //% block="on wake sequence detected"
    //% advanced="true"
    export function onWakeSequenceDetected(handler: ()=>void) {
        let clapDetector = ClapDetector.getClapDetector();
        clapDetector.setOnWakeDetected(handler);
    }

    //% block="on capture over"
    //% advanced="true"
    export function onCaptureOver(handler: ()=>void) {
        let clapDetector = ClapDetector.getClapDetector();
        clapDetector.setOnCaptureOver(handler);
    }
}
